#!/usr/bin/env python3

# Some of the module names are a bit unwieldy (as per assignment
# specification), so I alias some of them.
from instapy.gray.python_color2gray   import python_color2gray  as gray_python
from instapy.gray.numpy_color2gray    import numpy_color2gray   as gray_numpy
from instapy.gray.numba_color2gray    import numba_color2gray   as gray_numba
from instapy.sepia.python_color2sepia import python_color2sepia as sepia_python
from instapy.sepia.numpy_color2sepia  import numpy_color2sepia  as sepia_numpy
from instapy.sepia.numba_color2sepia  import numba_color2sepia  as sepia_numba
import instapy.utils
import argparse

if __name__ == "__main__":

  # Initialize the argument parser, and define some arguments.
  parser = argparse.ArgumentParser(description="Filter some images.")

  # Providing a filename is mandatory, a «positional argument». If not
  # provided, usage information is printed.
  parser.add_argument('file', metavar='FILE',
                      action='extend', type=str, nargs='+',
                      help='the filename(s) of file(s) to apply filter to')

  # Optional output filename. Doesn't really work when there are multiple input
  # files to be processed; they will just overwrite the same filename over and
  # over. Rather, use `--suffix`, which is mutually exclusive with `--out`.
  output = parser.add_mutually_exclusive_group()
  output.add_argument('-o', '--out', metavar='OUT', type=str,
                      help='the output file name (will be overwritten if '
                           'multiple input filenames)')
  output.add_argument('-su', '--suffix', metavar='SUFFIX', type=str,
                      help='suffix to add to (each) input filename when '
                           'saving output file(s)')

  # Add argument for which implementation to use. Multiple values are allowed,
  # and constructive for testing runtime.
  parser.add_argument('-i', '--implement',
                      choices=('python', 'numba', 'numpy'),
                      action='extend', type=str, nargs='+',
                      help='choose the implementation(s), otherwise use '
                           '\'numpy\'')

  # Add argument for testing runtime.
  parser.add_argument('-r', '--runtime', metavar='N',
                      type=int, nargs='?', const=3,
                      help='do runtime statistics, optional N number of runs,'
                           ' default to 3')

  # Add a mutually exclusive group for filters; you can only apply one filter
  # at a time. Print error message if attempted.
  filters = parser.add_mutually_exclusive_group()
  filters.add_argument('-se', '--sepia', metavar='LVL',
                       type=float, nargs='?', const=1.0,
                       help='apply sepia filter, optional 0-1 float for '
                            'desired level')
  filters.add_argument('-g', '--gray', metavar='LVL',
                       type=float, nargs='?', const=1.0,
                       help='apply greyscale filter, optional 0-1 float for '
                            'desired level')

  # Parse the command line arguments, according to the rules defined above.
  args = parser.parse_args()

  for file in args.file:

    image = instapy.utils.read_image(file)

    # If the `runtime` argument is passed, let that function do the rest, and
    # exit. `time()` will run on the entire set of `--implement` arguments
    # passed, i.e. running multiple implementation tests is allowed.

    if args.runtime != None:
      if args.implement:
        instapy.utils.runtime(image, implementations=set(args.implement),
                              number=args.runtime, gray=args.gray,
                              sepia=args.sepia)
      else:
        instapy.utils.runtime(image, number=args.runtime, gray=args.gray,
                              sepia=args.sepia)

    # Else, just do filtering. If no `--implement` argument is passed, use
    # numpy. If several `-i` arguments are passed (which is kinda pointless
    # without `--runtime`, but yeah), the preference is numpy > numba > python.

    elif args.gray != None:

      # Though the results of filter levels higher than 1.0 or levels lower
      # than 0.0 look entertaining, we'll take the boring route of prohibiting
      # such values.
      args.gray = min([1.0, args.gray])
      args.gray = max([0.0, args.gray])

      if args.suffix != None:
        args.suffix = '_gray'

      if (not args.implement) or 'numpy' in args.implement:
        image = gray_numpy(image, level=args.gray)
      elif 'numba' in args.implement:
        image = gray_numba(image, level=args.gray)
      elif 'python' in args.implement:
        image = gray_python(image, level=args.gray)

      # If no output filename or suffix was provided, save as output as input
      # filename + `_gray`.
      if args.out == None and args.suffix == None:
        args.suffix = '_gray'

    elif args.sepia != None:

      # Same as the greyscale-filter above: limit the filter level to the
      # interval [0.0, 1.0].
      args.sepia = min([1.0, args.sepia])
      args.sepia = max([0.0, args.sepia])

      if (not args.implement) or 'numpy' in args.implement:
        image = sepia_numpy(image, level=args.sepia)
      elif 'numba' in args.implement:
        image = sepia_numba(image, level=args.sepia)
      elif 'python' in args.implement:
        image = sepia_python(image, level=args.sepia)

      # If no output filename or suffix was provided, save as output as input
      # filename + `_sepia`.
      if args.out == None and args.suffix == None:
        args.suffix = '_sepia'

    # If a output filename was provided save image as this.
    if args.out != None:
      instapy.utils.save_image(args.out, image)
    else:
      instapy.utils.save_image(file, image, suffix=args.suffix)
